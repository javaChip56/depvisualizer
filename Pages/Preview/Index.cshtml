@page
@model dependencies_visualizer.Pages.Preview.IndexModel
@{
    ViewData["Title"] = "Preview";
}

<p class="text-muted mb-3">
    Project: <strong>@Model.CurrentProject?.Name</strong> / Sub Project: <strong>@Model.CurrentSubProject?.Name</strong>
    <a class="ms-2" asp-page="/Projects/Index">Switch project</a>
</p>

<h2>Dependency Graph Preview</h2>

<div class="d-flex gap-2 flex-wrap mb-3">
    <button id="btnRecenter" type="button" class="btn btn-outline-secondary btn-sm">Recenter</button>
    <button id="btnExportPng" type="button" class="btn btn-outline-primary btn-sm">Export PNG</button>
    <button id="btnExportJpg" type="button" class="btn btn-outline-primary btn-sm">Export JPG</button>
    <button id="btnExportSvg" type="button" class="btn btn-outline-primary btn-sm">Export SVG</button>
    @if (!Model.IsMaintainer)
    {
        <button id="btnResetLayout" type="button" class="btn btn-outline-warning btn-sm">Reset Layout</button>
    }
</div>
<p class="text-muted small">
    @(Model.IsMaintainer
        ? "Layout changes are shared with all project members."
        : "Layout changes are personal to your account. Use Reset Layout to revert to the maintainer layout.")
</p>
<p class="text-muted small mb-2">
    Edge editing: click an edge, then drag the blue dot to reposition the label.
</p>

<div id="cy" class="graph-surface"></div>
<style>
    #cy {
        position: relative;
    }

    .edge-edit-overlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
    }

    .edge-edit-handle {
        position: absolute;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        border: 2px solid #ffffff;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
        pointer-events: auto;
        cursor: grab;
        transform: translate(-50%, -50%);
        display: none;
    }

    .edge-edit-handle:active {
        cursor: grabbing;
    }

    .edge-edit-handle.label {
        background: #0d6efd;
    }
</style>

@section Scripts {
    <script src="https://unpkg.com/cytoscape@3.29.2/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/cytoscape-svg/cytoscape-svg.js"></script>
    <script>
        const elements = @Html.Raw(Model.CytoscapeElementsJson);
        const projectName = '@(Model.CurrentProject?.Name ?? "dependency-graph")';
        const isMaintainer = @Model.IsMaintainer.ToString().ToLowerInvariant();

        function sanitizeFileName(name) {
            return (name || "dependency-graph")
                .replace(/[<>:"/\\|?*\x00-\x1F]/g, "_")
                .replace(/\s+/g, "_")
                .replace(/_+/g, "_");
        }

        function downloadDataUri(filename, dataUri) {
            const a = document.createElement('a');
            a.href = dataUri;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        function hasPresetPositions(graphElements) {
            const nodeElements = graphElements
                .filter(e => e.data && e.data.id && e.data.id.startsWith('n'));

            if (nodeElements.length === 0) {
                return false;
            }

            return nodeElements.every(e =>
                e.position &&
                Number.isFinite(e.position.x) &&
                Number.isFinite(e.position.y));
        }

        async function savePositions(cy) {
            const nodes = {};
            cy.nodes().forEach(node => {
                const p = node.position();
                nodes[node.id()] = { x: p.x, y: p.y };
            });

            const edges = {};
            cy.edges().forEach(edge => {
                const data = edge.data();
                edges[edge.id()] = {
                    labelOffsetX: Number.isFinite(data.labelOffsetX) ? data.labelOffsetX : 0,
                    labelOffsetY: Number.isFinite(data.labelOffsetY) ? data.labelOffsetY : 0
                };
            });

            const response = await fetch('@Html.Raw(Url.Page("/Preview/Index", "SaveLayout", new { subProjectId = Model.SubProjectId }))', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ nodes, edges })
            });

            if (!response.ok) {
                return;
            }

            const payload = await response.json();
            if (!payload.success) {
                console.warn(payload.error || 'Unable to save layout.');
            }
        }

        let saveTimer = null;
        function queueSave(cy) {
            if (saveTimer) {
                clearTimeout(saveTimer);
            }
            saveTimer = setTimeout(() => {
                savePositions(cy);
            }, 250);
        }

        const shouldUsePreset = hasPresetPositions(elements);
        const hasCompoundHierarchy = elements.some(e => e.data && e.data.parent);
        const layoutConfig = shouldUsePreset
            ? {
                name: 'preset',
                fit: true,
                padding: 20
            }
            : {
                // First-load layout tuning: avoid overlap while keeping clusters reasonably compact.
                name: 'cose',
                fit: true,
                animate: false,
                padding: hasCompoundHierarchy ? 20 : 30,
                nodeDimensionsIncludeLabels: true,
                avoidOverlap: true,
                avoidOverlapPadding: hasCompoundHierarchy ? 10 : 18,
                idealEdgeLength: hasCompoundHierarchy ? 60 : 90,
                edgeElasticity: 120,
                nodeRepulsion: hasCompoundHierarchy ? 130000 : 450000,
                componentSpacing: hasCompoundHierarchy ? 25 : 60,
                nestingFactor: hasCompoundHierarchy ? 0.7 : 1.1,
                gravity: hasCompoundHierarchy ? 1.8 : 1,
                numIter: 1200
            };

        if (window.cytoscape && window.cytoscapeSvg) {
            window.cytoscape.use(window.cytoscapeSvg);
        }

        const cy = cytoscape({
            container: document.getElementById('cy'),
            elements,
            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': 'data(fillColor)',
                        'background-opacity': 1,
                        'border-width': 1,
                        'border-color': 'data(lineColor)',
                        'shape': 'data(shape)',
                        'label': 'data(label)',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '8px',
                        'text-wrap': 'none',
                        'color': '#000000'
                    }
                },
                {
                    selector: 'node[isCompoundType = false]',
                    style: {
                        'width': 'label',
                        'height': 26,
                        'padding-left': 10,
                        'padding-right': 10
                    }
                },
                {
                    selector: 'node:parent',
                    style: {
                        'background-opacity': 0.2,
                        'border-style': 'dashed',
                        'text-valign': 'top',
                        'text-halign': 'center',
                        'padding': '20px'
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'curve-style': 'taxi',
                        'taxi-direction': 'auto',
                        'taxi-turn': 30,
                        'source-arrow-shape': 'data(sourceArrowShape)',
                        'target-arrow-shape': 'data(targetArrowShape)',
                        'line-style': 'data(lineStyle)',
                        'text-margin-x': 'data(labelOffsetX)',
                        'text-margin-y': 'data(labelOffsetY)',
                        'line-color': '#6c757d',
                        'source-arrow-color': '#6c757d',
                        'target-arrow-color': '#6c757d',
                        'width': 1,
                        'label': 'data(label)',
                        'font-size': '10px',
                        'text-background-color': '#ffffff',
                        'text-background-opacity': 1,
                        'text-background-padding': '2px'
                    }
                },
                {
                    selector: 'edge.edge-selected',
                    style: {
                        'width': 2,
                        'line-color': '#0d6efd',
                        'source-arrow-color': '#0d6efd',
                        'target-arrow-color': '#0d6efd'
                    }
                }
            ],
            layout: layoutConfig
        });

        cy.on('dragfree', 'node', () => queueSave(cy));
        cy.on('layoutstop', () => queueSave(cy));

        const overlay = document.createElement('div');
        overlay.className = 'edge-edit-overlay';
        const labelHandle = document.createElement('div');
        labelHandle.className = 'edge-edit-handle label';
        labelHandle.title = 'Drag label';
        overlay.appendChild(labelHandle);
        document.getElementById('cy')?.appendChild(overlay);

        const hideEdgeHandles = () => {
            labelHandle.style.display = 'none';
        };

        const setHandlePosition = (handle, x, y) => {
            handle.style.left = `${x}px`;
            handle.style.top = `${y}px`;
            handle.style.display = 'block';
        };

        const updateEdgeHandles = () => {
            if (!selectedEdge || selectedEdge.removed()) {
                hideEdgeHandles();
                return;
            }

            let midpoint = null;
            if (typeof selectedEdge.renderedMidpoint === 'function') {
                midpoint = selectedEdge.renderedMidpoint();
            } else if (typeof selectedEdge.midpoint === 'function') {
                const point = selectedEdge.midpoint();
                const zoom = cy.zoom();
                const pan = cy.pan();
                midpoint = { x: (point.x * zoom) + pan.x, y: (point.y * zoom) + pan.y };
            }

            if (!midpoint) {
                hideEdgeHandles();
                return;
            }

            const data = selectedEdge.data();
            const labelOffsetX = Number.isFinite(data.labelOffsetX) ? data.labelOffsetX : 0;
            const labelOffsetY = Number.isFinite(data.labelOffsetY) ? data.labelOffsetY : 0;

            setHandlePosition(labelHandle, midpoint.x + labelOffsetX, midpoint.y + labelOffsetY);
        };

        let selectedEdge = null;
        const updateEdgeSelection = (edge) => {
            if (selectedEdge && selectedEdge.id() === edge?.id()) {
                return;
            }

            if (selectedEdge) {
                selectedEdge.removeClass('edge-selected');
            }

            selectedEdge = edge || null;
            if (selectedEdge) {
                selectedEdge.addClass('edge-selected');
            }

            updateEdgeHandles();
        };

        cy.on('tap', 'edge', (event) => {
            updateEdgeSelection(event.target);
        });

        cy.on('tap', (event) => {
            if (event.target === cy) {
                updateEdgeSelection(null);
            }
        });

        let dragState = null;
        const pointerToRendered = (event) => {
            const rect = cy.container().getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        };

        const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

        const beginHandleDrag = (kind, event) => {
            if (!selectedEdge) {
                return;
            }

            event.preventDefault();
            event.stopPropagation();

            const data = selectedEdge.data();
            dragState = {
                edgeId: selectedEdge.id(),
                labelOffsetX: Number.isFinite(data.labelOffsetX) ? data.labelOffsetX : 0,
                labelOffsetY: Number.isFinite(data.labelOffsetY) ? data.labelOffsetY : 0
            };

            cy.userPanningEnabled(false);
        };

        labelHandle.addEventListener('mousedown', (event) => beginHandleDrag('label', event));

        document.addEventListener('mousemove', (event) => {
            if (!dragState || !selectedEdge) {
                return;
            }

            if (selectedEdge.id() !== dragState.edgeId) {
                dragState = null;
                cy.userPanningEnabled(true);
                return;
            }

            const pointer = pointerToRendered(event);
            let midpoint = null;
            if (typeof selectedEdge.renderedMidpoint === 'function') {
                midpoint = selectedEdge.renderedMidpoint();
            } else if (typeof selectedEdge.midpoint === 'function') {
                const point = selectedEdge.midpoint();
                const zoom = cy.zoom();
                const pan = cy.pan();
                midpoint = { x: (point.x * zoom) + pan.x, y: (point.y * zoom) + pan.y };
            }

            if (!midpoint) {
                return;
            }

            selectedEdge.data({
                labelOffsetX: clamp(pointer.x - midpoint.x, -300, 300),
                labelOffsetY: clamp(pointer.y - midpoint.y, -300, 300)
            });

            updateEdgeHandles();
            queueSave(cy);
        });

        document.addEventListener('mouseup', () => {
            dragState = null;
            cy.userPanningEnabled(true);
        });

        cy.on('render pan zoom resize', () => updateEdgeHandles());
        cy.on('position', 'node', () => updateEdgeHandles());
        cy.on('data', 'edge', () => updateEdgeHandles());

        document.getElementById('btnRecenter')?.addEventListener('click', () => {
            cy.fit(undefined, 30);
            cy.center();
        });

        document.getElementById('btnExportPng')?.addEventListener('click', () => {
            const dataUri = cy.png({ full: true, scale: 2, bg: '#ffffff' });
            downloadDataUri(`${sanitizeFileName(projectName)}.png`, dataUri);
        });

        document.getElementById('btnExportJpg')?.addEventListener('click', () => {
            const dataUri = cy.jpg({ full: true, scale: 2, bg: '#ffffff', quality: 0.95 });
            downloadDataUri(`${sanitizeFileName(projectName)}.jpg`, dataUri);
        });

        document.getElementById('btnExportSvg')?.addEventListener('click', () => {
            if (typeof cy.svg !== 'function') {
                alert('SVG export is not available in this browser right now.');
                return;
            }

            const svg = cy.svg({ full: true, scale: 1, bg: '#ffffff' });
            const svgBlob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
            const svgUrl = URL.createObjectURL(svgBlob);
            downloadDataUri(`${sanitizeFileName(projectName)}.svg`, svgUrl);
            setTimeout(() => URL.revokeObjectURL(svgUrl), 1000);
        });

        document.getElementById('btnResetLayout')?.addEventListener('click', async () => {
            if (isMaintainer) {
                return;
            }

            const response = await fetch('@Html.Raw(Url.Page("/Preview/Index", "ResetLayout", new { subProjectId = Model.SubProjectId }))', {
                method: 'POST'
            });
            if (!response.ok) {
                alert('Unable to reset layout.');
                return;
            }

            const payload = await response.json();
            if (!payload.success) {
                alert(payload.error || 'Unable to reset layout.');
                return;
            }

            window.location.reload();
        });
    </script>
}
